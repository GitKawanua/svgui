{"version":3,"file":"gzip-worker.js","sources":["../../node_modules/pako/lib/utils/common.js","../../node_modules/pako/lib/zlib/trees.js","../../node_modules/pako/lib/zlib/adler32.js","../../node_modules/pako/lib/zlib/crc32.js","../../node_modules/pako/lib/zlib/deflate.js","../../node_modules/pako/lib/zlib/messages.js","../../node_modules/pako/lib/utils/strings.js","../../node_modules/pako/lib/deflate.js","../../node_modules/pako/lib/zlib/zstream.js","../../src/js/gzip-worker/index.js"],"sourcesContent":["'use strict';\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n","'use strict';\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n","'use strict';\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = require('../utils/common');\nvar trees   = require('./trees');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n","// String encode/decode helpers\n'use strict';\n\n\nvar utils = require('./common');\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n","'use strict';\n\n\nvar zlib_deflate = require('./zlib/deflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n","import {gzip} from 'pako/lib/deflate';\n\nself.onmessage = function(event) {\n  try {\n    var result = gzip(event.data.data).buffer;\n    self.postMessage({\n      id: event.data.id,\n      result: result\n    });\n  }\n  catch (error) {\n    self.postMessage({\n      id: event.data.id,\n      error: error.message\n    });\n  }\n};"],"names":["TYPED_OK","Uint8Array","Uint16Array","Int32Array","_has","obj","key","Object","prototype","hasOwnProperty","call","exports","sources","Array","slice","arguments","length","source","shift","TypeError","p","buf","size","subarray","fnTyped","arraySet","dest","src","src_offs","len","dest_offs","set","i","flattenChunks","chunks","l","pos","chunk","result","fnUntyped","concat","apply","on","assign","setTyped","utils","require$$0","zero","LITERALS","L_CODES","D_CODES","MAX_BITS","extra_lbits","extra_dbits","extra_blbits","bl_order","static_ltree","static_dtree","_dist_code","_length_code","MAX_MATCH","base_length","static_l_desc","static_d_desc","static_bl_desc","base_dist","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","this","has_stree","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","put_short","s","w","pending_buf","pending","send_bits","value","bi_valid","bi_buf","send_code","c","tree","bi_reverse","code","res","gen_codes","bl_count","bits","n","next_code","init_block","dyn_ltree","dyn_dtree","bl_tree","END_BLOCK","opt_len","static_len","last_lit","matches","bi_windup","smaller","m","depth","_n2","_m2","pqdownheap","k","v","heap","j","heap_len","compress_block","ltree","dtree","lc","extra","lx","d_buf","l_buf","build_tree","desc","node","stree","heap_max","h","xbits","f","base","overflow","gen_bitlen","scan_tree","curlen","prevlen","nextlen","count","max_count","min_count","REP_3_6","REPZ_3_10","REPZ_11_138","send_tree","static_init_done","_tr_stored_block","stored_len","last","header","window","copy_block","LENGTH_CODES","tr_static_init","l_desc","d_desc","bl_desc","opt_lenb","static_lenb","max_blindex","level","strm","data_type","black_mask","detect_data_type","BL_CODES","build_bl_tree","strategy","lcodes","dcodes","blcodes","rank","send_all_trees","lit_bufsize","STATIC_TREES","bi_flush","adler32_1","adler","s1","s2","crcTable","table","makeTable","configuration_table","messages","trees","require$$1","adler32","require$$2","crc32","crc","t","end","msg","require$$4","Z_STREAM_ERROR","MIN_LOOKAHEAD","HCRC_STATE","BUSY_STATE","FINISH_STATE","err","errorCode","flush_pending","state","avail_out","output","pending_out","next_out","total_out","flush_block_only","_tr_flush_block","block_start","strstart","put_byte","b","putShortMSB","longest_match","cur_match","match","chain_length","max_chain_length","scan","best_len","prev_length","nice_match","limit","w_size","_win","wmask","w_mask","prev","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","more","str","start","_w_size","window_size","hash_size","head","avail_in","input","next_in","wrap","total_in","insert","ins_h","hash_shift","hash_mask","deflate_fast","flush","hash_head","bflush","match_length","_tr_tally","max_lazy_match","MIN_MATCH","deflate_slow","max_insert","prev_match","match_available","Config","good_length","max_lazy","nice_length","max_chain","func","DeflateState","status","pending_buf_size","gzhead","gzindex","method","last_flush","w_bits","hash_bits","Buf16","HEAP_SIZE","deflateResetKeep","_tr_init","deflateReset","ret","deflateInit2","windowBits","memLevel","Buf8","max_block_size","max_start","old_flush","beg","val","text","hcrc","name","comment","time","os","charCodeAt","bstate","deflate_huff","deflate_rle","_tr_align","dictionary","avail","next","tmpDict","dictLength","STR_APPLY_OK","STR_APPLY_UIA_OK","String","fromCharCode","__","_utf8len","q","buf2binstring","shrinkBuf","c2","m_pos","str_len","buf_len","max","out","c_len","utf16buf","zlib_deflate","strings","require$$3","ZStream","toString","Deflate","options","chunkSize","to","opt","raw","gzip","ended","Error","deflateSetHeader","dict","string2buf","deflateSetDictionary","_dict_set","push","data","mode","_mode","deflate","onEnd","onData","deflateEnd","join","deflator","self","onmessage","event","buffer","postMessage","id","error","message"],"mappings":"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"}